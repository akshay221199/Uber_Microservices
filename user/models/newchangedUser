import mongoose from "mongoose";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import crypto from "crypto";

const { Schema } = mongoose;

const userSchema = new Schema(
  {
    name: {
      type: String,
      required: true,
    },
    email: {
      type: String,
      required: true,
      unique: true, // ensures no duplicate emails
    },
    contact: {
      type: Number,
      required: true,
    },
    refreshToken: {
      type: String, // store hashed refresh token
    },
    password: {
      type: String,
      required: true,
    },
  },
  {
    timestamps: true,
  }
);

// Hash password before saving
userSchema.pre("save", async function (next) {
  if (!this.isModified("password")) return next();
  this.password = await bcrypt.hash(this.password, 12); // stronger hash
  next();
});

// Compare password
userSchema.methods.isPasswordCorrect = async function (password) {
  return await bcrypt.compare(password, this.password);
};

// Generate JWT access token (short-lived)
userSchema.methods.generateAccessToken = function () {
  return jwt.sign(
    { _id: this._id, email: this.email },
    process.env.ACCESS_TOKEN_SECRET,
    { expiresIn: process.env.ACCESS_TOKEN_EXPIRY || "15m" }
  );
};

// Generate refresh token (long-lived) and hash it for DB storage
userSchema.methods.generateRefreshToken = function () {
  // Generate random 64-byte string
  const rawToken = crypto.randomBytes(64).toString("hex");

  // Hash before saving in DB
  const hashedToken = crypto.createHash("sha256").update(rawToken).digest("hex");
  this.refreshToken = hashedToken; // save hashed version in DB

  return rawToken; // return raw token to send to client (store in httpOnly cookie)
};

// Verify refresh token (pass raw token from client)
userSchema.methods.verifyRefreshToken = function (token) {
  const hashedToken = crypto.createHash("sha256").update(token).digest("hex");
  return this.refreshToken === hashedToken;
};

export default mongoose.model("User", userSchema);
